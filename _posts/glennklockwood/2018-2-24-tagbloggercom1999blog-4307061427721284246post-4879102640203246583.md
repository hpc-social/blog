---
author: Glenn K. Lockwood's Blog
author_tag: glennklockwood
blog_subtitle: Personal thoughts and opinions of a supercomputing enthusiast
blog_title: Glenn K. Lockwood
blog_url: https://glennklockwood.blogspot.com/search/label/hpc
category: glennklockwood
date: '2018-02-24 09:21:00'
layout: post
original_url: https://glennklockwood.blogspot.com/2018/02/are-fpgas-answer-to-hpcs-woes.html
slug: are-fpgas-the-answer-to-hpc-s-woes-
title: Are FPGAs the answer to HPC's woes?
---

<bound method Tag.renderContents of <h2>Executive Summary</h2>Not yet.  I'll demonstrate why no domain scientist would ever want to program in Verilog, then highlight a few promising directions of development that are addressing this fact.<br/><br/>The usual disclaimer also applies: the opinions and conjectures expressed below are mine alone and not those of my employer.  Also I am not a computer scientist, so I probably don't know what I'm talking about.  And even if it seems like I do, remember that I am a storage architect who is wholly unqualified to speak on applications and processor performance.<br/><br/><h2>Premise</h2>We're now in an age where CPU cores aren't getting any faster, and the difficulties of shrinking processes below 10 nm means we can't really pack any more CPU cores on a die.  Where's performance going to come from if we ever want to get to exascale and beyond?<br/><br/>Some vendors are betting on <b>larger and larger vectors</b>--<a href="https://community.arm.com/processors/b/blog/posts/technology-update-the-scalable-vector-extension-sve-for-the-armv8-a-architecture">ARM (with its Scalable Vector Extensions)</a> and <a href="http://www.nec.com/en/global/solutions/hpc/sx/vector_engine.html">NEC (with its Aurora coprocessors)</a> are going down this path.  However, algorithms that aren't predominantly dense linear algebra will need very efficient scatter and gather operations that can pack vector registers quickly enough to make doing a single vector operation worthwhile.  For example, gathering eight 64-bit values from different parts of memory to issue an eight-wide (512-bit) vector multiply requires pulling eight different cache lines--that's moving 4096 bits of memory for what amounts to 512 bits of computation.  In order to continue scaling vectors out, CPUs will have to rethink how their vector units interact with memory.  This means either (a) getting a lot more memory bandwidth to support these low <a href="http://www.nersc.gov/users/application-performance/measuring-arithmetic-intensity/">flops-per-byte ratios</a>, or (b) pack vectors closer to the memory so that pre-packed vectors can be fetched through the existing memory channels.<br/><br/>Another option to consider are <b>GPUs</b>, which work around the vector packing issue by implementing a massive numbers of registers and giant crossbars to plumb those bytes into arithmetic units.  Even then, though, relying on a crossbar to connect compute and data is difficult to continue scaling; the interconnect industry gave up on this long ago, which is why today's clusters now connect hundreds or thousands of crossbars into larger fat trees, hypercubes, and dragonflies.  GPUs are still using larger and larger crossbars--NVIDIA's V100 GPU is one of the <a href="https://arstechnica.com/gadgets/2017/05/nvidia-tesla-v100-gpu-details/">physically largest single-die chips ever made</a>--but there's an economic limit to how large a die can be.<br/><br/>This bleak outlook has begun to drive HPC designers towards thinking about smarter ways to use silicon.  Rather than build a general-purpose processor that can do all multiplication and addition operations at a constant rate, the notion is to bring hardware design closer to the algorithms being implemented.  This isn't a new idea (for example, <a href="http://dx.doi.org/10.1098/rsta.2013.0387">RIKEN's MDGRAPE</a> and <a href="http://dx.doi.org/10.1109/SC.2014.9">DESRES's Anton</a> are famous examples of purpose-built chips for specific scientific application areas), but this approach historically has been very expensive relative to just using general-purpose processor parts.  Only now are we at a place where special-purpose hardware may be the only way to sustain HPC's performance trajectory.<br/><br/>Given the diversity of applications that run on the modern supercomputer though, expensive and custom chips that only solve one problem aren't very appetizing.  A close compromise are FPGAs though, and there has been a growing buzz surrounding the viability of relying on FPGAs in mainstream HPC workloads.<br/><br/>Many of us non-computer scientists in the HPC business only have a vague and qualitative notion of how FPGAs can realistically be used to carry out computations, though.  Since there is growing excitement around FPGAs for HPC as exascale approaches though, I set out to get my hands dirty and figure out how they might fit in the larger HPC ecosystem.<br/><br/><h2>Crash course in Verilog</h2>Verilog can be very difficult to grasp for people who already know how to program languages like C or Fortran (like me!).  On the one hand, it looks a bit like C in that has variables to which values can be assigned, if/then/else controls, for loops, and so on.  However these similarities are deceptive because Verilog does <i>not</i> execute like C; whereas a C program executes code line by line, one statement after the other, Verilog sort of execute all of the lines at the same time, all the time.<br/><br/>A C program to turn an LED on and off repeatedly might look like:<br/><br/><div></div>
where the LED is turned on, <i>then</i> the LED is turned off, <i>then</i> we repeat.<br/><br/>In Verilog, you really have to describe <i>what</i> components your program will have and <i>how</i> they are connected.  In the most basic way, the code to blink an LED in Verilog would look more like<br/><br/><div></div>
<br/>Whereas C is a <i>procedural</i> language in that you describe a procedure for solving a problem, Verilog is more like a <i>declarative</i> language in that you describe how widgets can be arranged to solve the problem.<br/><br/>This can make tasks that are simple to accomplish in C comparatively awkward in Verilog.  Take our LED blinker C code above as an example; if you want to slow down the blinking frequency, you can do something like<br/><br/><div></div>
<br/>Because Verilog is not procedural, there is no simple way to say "wait a second <i>after</i> you turn on the LED before doing something else."  Instead, you have to rely on knowing how much time passes between consecutive clock signals (<code>clk</code> incrementing).<br/><br/>For example, the DE10-Nano has a 50 MHz clock generator, so every 1/(50 MHz) (20 nanoseconds), and everything time-based has to be derived from this fundamental clock timer.  The following Verilog statement:<br/><br/><div></div>
<br/>indicates that every 20 ns, increment the <code>cnt</code> register (variable) by one.  To make the LED wait for one second after the LED is turned on, we need to figure out a way to do nothing for 50,000,000 clock cycles (1 second / 20 nanoseconds).  The canonical way to do this is to<br/><ol><li>create a big register that can store a number up to 50 million</li><li>express that this register should be incremented by 1 on every clock cycle</li><li>create a logic block that turns on the LED when our register is larger than 50 million</li><li>rely on the register eventually overflowing to go back to zero</li></ol>If we make <code>cnt</code> a 26-bit register, it can count up to 67,108,864 different numbers and our Verilog can look something like<br/><br/><div></div>
<br/>However, we are still left with two problems:<br/><ol><li><code>cnt</code> will overflow back to zero once <code>cnt</code> surpasses 2<sup>26</sup> - 1</li><li>We don't yet know how to express how the LED is connected to our FPGA and should be controlled by our circuit</li></ol>Problem #1 (<code>cnt</code> overflows) means that the LED will stay <i>on</i> for exactly 50,000,000 clock cycles (1 second), but it'll turn <i>off</i> for only 2<sup>26</sup> - 1 - 50,000,000 cycles (17,108,860 cycles, or 0.34 seconds).  Not exactly the one second on, one second off that our C code does.<br/><br/>Problem #2 is solved by understanding the following:<br/><br/><ul><li>our LED is external to the FPGA, so it will be at the end of an <i>output wire</i></li><li>the other end of that <i>output wire</i> must be connected to something inside our circuit--a register, another wire, or something else</li></ul><br/>The conceptually simplest solution to this problem is to create another register (variable), this time only one bit wide, in which our LED state will be stored.  We can then change the state of this register in our <code>if (cnt &gt; 5000000)</code> block and wire that register to our external LED:<br/><br/><div></div>
<br/>Note that our <code>assign</code> statement is outside of our <code>always @(posedge clk)</code> block because this assignment--connecting our <code>led</code> output wire to our <code>led_state</code> register--is a persistent declaration, <i>not</i> the assignment of a particular value.  We are saying "whatever value is stored in <code>led_state</code> should always be carried to whatever is on the other end of the <code>led</code> wire."  Whenever <code>led_state</code> changes, <code>led</code> will simultaneously change as a result.<br/><br/>With this knowledge, we can actually solve Problem #1 now by<br/><ol><li>only counting up to 50 million and not relying on overflow of <code>cnt</code> to turn the LED on or off, and</li><li>overflowing the 1-bit <code>led_state</code> register every 50 million clock cycles</li></ol>Our Verilog module would look like<br/><br/><div></div>
<br/>and we accomplish the "hello world" of circuit design:<br/><br/><div class="separator" style="clear: both; text-align: center;"><a href="https://4.bp.blogspot.com/-HwPyRg8Kc6U/Wm0vBaXxf5I/AAAAAAAA0Ho/QKNf3Kn4EqcqdPSl3uUxX8h_fAB9oxSeACLcBGAs/s1600/fpga-blink-1sec.gif" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="239" src="https://4.bp.blogspot.com/-HwPyRg8Kc6U/Wm0vBaXxf5I/AAAAAAAA0Ho/QKNf3Kn4EqcqdPSl3uUxX8h_fAB9oxSeACLcBGAs/s320/fpga-blink-1sec.gif" width="320"/></a></div>
<br/>This Verilog is actually still missing a number of additional pieces and makes very inefficient use of the FPGA's hardware resources.  However, it shows how awkward it can be to express a simple, four-line procedural program using a hardware description language like Verilog.<br/><br/><h2>So why bother with FPGAs at all?</h2>It should be clear that solving a scientific problem using a procedural language like C is generally more straightforward than with a declarative language like Verilog.  That ease of programming is made possible by a ton of hardware logic that isn't always used, though.<br/><br/>Consider our blinking LED example; because the C program is procedural, it takes one CPU thread to walk through the code in our program.  Assuming we're using a 64-core computer, that means we can only blink up to 64 LEDs at once.  On the other hand, our Verilog module consumes a tiny number of the programmable logic blocks on an FPGA.  When compiled for a $100 hobbyist-grade DE10-Nano FPGA system, it uses only 21 of 41,910 programmable blocks, meaning it can control almost 2,000 LEDs concurrently**.  A high-end FPGA would easily support tens of thousands. <br/><br/><table cellpadding="0" cellspacing="0" class="tr-caption-container" style="display: block; float: right; margin-left: 1em; text-align: right;"><tbody><tr><td style="text-align: center;"><a href="https://4.bp.blogspot.com/-dv03oqFBdTs/WpEAAg9THGI/AAAAAAAA0Tc/LV6L-sK7S4k3jK4bY8SHja0NynW518QqwCLcBGAs/s1600/cm200-6.jpg" style="clear: right; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" height="261" src="https://4.bp.blogspot.com/-dv03oqFBdTs/WpEAAg9THGI/AAAAAAAA0Tc/LV6L-sK7S4k3jK4bY8SHja0NynW518QqwCLcBGAs/s320/cm200-6.jpg" width="320"/></a></td></tr><tr><td class="tr-caption" style="text-align: center;">The CM2 illuminated an LED whenever an operation was in flight. Blinking the LED in Verilog is easy.  Reproducing the CM2 microarchitecture is a different story.  Image credit to <a href="http://www.corestore.org/cm200.htm">Corestore</a>.</td></tr></tbody></table>Of course, blinking LEDs haven't been relevant to HPC since the days of Connection Machines, but if you were to replace LED-blinking logic with floating point arithmetic units, the same conclusions apply.  In principle, a single FPGA can process a huge number of FLOPS every cycle by giving up its ability to perform many of the tasks that a more general-purpose CPU would be able to do.  And because FPGAs are reprogrammable, they can be quickly configured to have an optimal mix of special-purpose parallel ALUs and general purpose capabilities to suit different application requirements.<br/><br/>However, the fact that the fantastic potential of FPGAs hasn't materialized into widespread adoption is a testament to how difficult it is to bridge the wide chasm between understanding how to solve a physics problem and understanding how to design a microarchitecture.<br/><br/><h2>Where FPGAs fit in HPC today</h2>To date, a few scientific domains have had success in using FPGAs.  For example,<br/><br/><ul><li>Experimental instruments that generate data commonly deploy FPGAs close to their detectors to perform very repetitive, relatively simple data filtering or manipulation at extremely high rates.  For example, <a href="https://blogs.swarthmore.edu/Illumina+GAIIx+Teardown/?p=125#div-comment-191">Illumina HiSeq DNA sequencers incorporate both Altera and Xilinx FPGAs</a> to assist with the high-throughput image processing, and <a href="https://www.nextplatform.com/2016/01/05/an-expanding-role-for-fpgas-in-cerns-future/">high-energy physics experiments routinely use FPGAs</a> for signal processing.</li><li>Closer to the HPC side, <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3186629/">Convey implemented loadable FPGA blocks to perform many algorithms common to bioinformatics</a>.  For example, they provided an FPGA-accelerated Smith-Waterman algorithm; this algorithm is used to align short DNA sequences along a reference genome and must be executed thousands of times per genome before actual genomic analysis can start.</li><li>More recently, <a href="http://edicogenome.com/dragen-bioit-platform/">Edico Genome</a> has been very successful in implementing a wide range of common bioinformatics algorithms on FPGA and providing end-to-end analysis processing pipelines that act as drop-in replacements for standard genomic analysis pipelines.</li></ul><div>The success of these FPGA products is due in large part to the fact that the end-user scientists don't ever have to directly interact with the FPGAs.  In the case of experimental detectors, FPGAs are sufficiently close to the detector that the "raw" data that is delivered to the researcher has already been processed by the FPGAs.  Convey and Edico products incorporate their FPGAs into an appliance, and the process of offloading certain tasks to the FPGA in proprietary applications that, to the research scientist, look like any other command-line analysis program.</div>
<div><br/></div>
<div>With all this said, the fact remains that these use cases are all on the fringe of HPC.  They present a black-and-white decision to researchers; to benefit from FPGAs, scientists must completely buy into the applications, algorithms, and software stacks.  Seeing as how these FPGA HPC stacks are often closed-source and proprietary, the benefit of being able to see, modify, and innovate on open-source scientific code often outweighs the speedup benefits of the fast-but-rigid FPGA software ecosystem.</div>
<div><br/></div>
<h2>Where FPGAs will fit in HPC tomorrow</h2><div>The way I see it, there are two things that must happen before FPGAs can become a viable general-purpose technology for accelerating HPC:</div>
<div><ol><li>Users must be able to integrate FPGA acceleration into their existing applications rather than replace their applications wholesale with proprietary FPGA analogues.</li><li>It has to be as easy as <span>f90 -fopenacc</span> or <span>nvcc</span> to build an FPGA-accelerated application, and running the resulting accelerated binary has to be as easy as running an unaccelerated binary.</li></ol><div>The first steps towards realizing this have already been made; both <a href="https://www.xilinx.com/products/design-tools/software-zone/sdaccel.html">Xilinx</a> and <a href="https://www.altera.com/products/design-software/embedded-software-developers/opencl/overview.html">Intel/Altera</a> now offer OpenCL runtime environments that allow scientific applications to offload computational kernels to the FPGA.  The Xilinx environment operates much like an OpenCL accelerator, where specific kernels are compiled for the FPGA and loaded as application-specific logic; the Altera environment installs a special OpenCL runtime environment on the FPGA.  However, there are a couple of challenges:</div>
</div>
<div><ul><li>OpenCL tends to be very messy to code in compared to simpler APIs such as OpenACC, OpenMP, CUDA, or HIP.  As a result, not many HPC application developers are investing in OpenCL anymore.</li><li>Compiling an application for OpenCL on an FPGA still requires going through the entire Xilinx or Altera toolchain.  At present, this is <i><u>not</u></i> as simple as <span>f90 -fopenacc</span> or <span>nvcc</span>, and the process of compiling code that targets an FPGA can take orders of magnitude longer than it would for a CPU due to the NP-hard nature of placing and routing across all the programmable blocks.</li><li>The FPGA OpenCL stacks are not as polished and scientist-friendly right now; performance analysis and debugging generally still has to be done at the circuit level, which is untenable for domain scientists.</li></ul><div>Fortunately, these issues are under very active development, and the story surrounding FPGAs for HPC application improves on a month by month basis.  We're still years from FPGAs becoming a viable option for accelerating scientific applications in a general sense, but when that day comes, I predict that programming in Verilog for FPGAs will seem as exotic as programming in assembly is for CPUs.</div>
</div>
<div><br/></div>
<div>Rather, applications will likely rely on large collections of pre-compiled FPGA IP blocks (often called <i>FPGA overlays</i>) that map to common compute kernels.  It will then be the responsibility of compilers to identify places in the application source code where these logic blocks should be used to offload certain loops.  Since it's unlikely that a magic compiler will be able to identify these loops on their own, users will still have to rely on OpenMP, OpenACC, or some other API to provide hints at compile time.  Common high-level functions, such as those provided by LAPACK, will probably also be provided by FPGA vendors as pre-compiled overlays that are hand-tuned.</div>
<div><br/></div>
<h2>Concluding Thoughts</h2><div>We're still years away from FPGAs being a viable option for mainstream HPC, and as such, I don't anticipate them as being the key technology that will underpin the world's first exascale systems.  Until the FPGA software ecosystem and toolchain mature to a point where domain scientists never have to look at a line of Verilog, FPGAs will remain an accelerator technology at the fringes of HPC.</div>
<div><br/></div>
<div>However, there is definitely a path for FPGAs to become mainstream, and forward progress is being made.  Today's clunky OpenCL implementations are already being followed up by <a href="https://www.nextplatform.com/2016/10/19/turning-openmp-programs-parallel-hardware/">research into providing OpenMP-based FPGA acceleration</a>, and proofs of concept demonstrating <a href="https://ft.ornl.gov/sites/default/files/IPDPS16_OpenACC2FPGA_PPT.pdf">OpenACC-based FPGA acceleration</a> have shown promising levels of performance portability.  On the hardware side, FPGAs are also approaching first-class citizenship with <a href="https://www.nextplatform.com/2017/10/02/intel-gears-fpga-push/">Intel planning to ship Xeons with integrated FPGAs in 2H2018</a> and <a href="https://www.alpha-data.com/dcp/products.php?product=adm-pcie-9v3">OpenPOWER beginning to ship Xilinx FPGAs with OpenCAPI-based coherence links for POWER9</a>.</div>
<div><br/></div>
<div>The momentum is growing, and the growing urgency surrounding post-Moore computing technology is driving investments and demand from both public and private sectors.  FPGAs won't be the end-all solution that gets us to exascale, nor will it be the silver bullet that gets us beyond Moore's Law computing, but they will definitely play an increasingly important role in HPC over the next five to ten years.</div>
<div><br/></div>
<div>If you've gotten this far and are interested in more information, I strongly encourage you to check out <a href="https://science.energy.gov/~/media/ascr/ascac/pdf/meetings/201612/Finkel_FPGA_ascac.pdf">FPGAs for Supercomputing: The Why and How</a>, presented by Hal Finkel, Kazutomo Yoshii, and Franck Cappello at ASCAC.  It provides more insight into the application motifs that FPGAs can accelerate, and a deeper architectural treatment of FPGAs as understood by real computer scientists.</div>
<div><br/></div>
<span style="font-size: xx-small;">** This is not really true.  Such a design would be limited by the number of physical pins coming out of the FPGA; in reality, output pins would have to be multiplexed, and additional logic to drive this multiplexing would take up FPGA real estate.  But you get the point.</span><br/><span>Save</span><span>Save</span><br/><span>Save</span><span>Save</span><span>Save</span><span>Save</span>>